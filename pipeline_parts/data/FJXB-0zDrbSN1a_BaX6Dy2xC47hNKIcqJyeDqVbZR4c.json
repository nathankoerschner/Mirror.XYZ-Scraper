"{\"content\":{\"body\":\"*This post was originally published March 4, 2019 on [Medium](https://medium.com/ethereum-magicians/q-a-on-eth-2-0-ab1d5d3ac133).*\\n\\n\\n---\\n\\n## Serenity session at ETHMagicians: Paris 2019\\n\\n*Participants: Mehdi Zerouali (Sigma Prime), Diederik Loerakker / Protolambda (independent developer), Zak Cole (Whiteblock), Justin Drake (EF), Carl Beekhuizen* *(EF), Yannick Luhn(Brainbot), Greg Markou (Chainsafe), Lane Rettig (EWASM)*\\n\\n*Facilitated by Lane Rettig and María Paula Fernández.*\\n\\n*Note: the dialogue has been modified and condensed for easier readability — this is meant as a rough transcript. Please reach out to the people mentioned on gitter if you have more specific questions.*\\n\\n## 1. Transition from 1.0 to 2.0: are any hard forks required?\\n\\n**Justin**- Zero hardforks are needed. The only prerequisite would be to set up the deposit contract on 1.0. However, a hard fork on 1.0 could add the functionality of finality taken from 2.0. This allows issuance to be drastically reduced (factor of 10 or 20, near the security of Ethereum Classic). Every 6 minutes the chain is finalised, conceivably could come to rely only on transaction fees. Other benefit from finalisation is fungibility of the ETH token, two-way transfer between the two chains.\\n\\nFinalisation of blocks is an independent effort from 2.0. It is key that 1.0 clients are aware of the 2.0 chain — this is either as a full node of the beacon chain OR by being a light client of both. It will take time for this to occur, perhaps near Phase 1, sometime next year.\\n\\n## 2. Transition from 1.0 to 2.0: what is the path for Dapp developers?\\n\\n**Greg**- It might be too early. Could drain resources from both researchers and dapp developers to explore this now.\\n\\n**Zak**- Agrees it is too early, the spec isn’t entirely complete yet. No defined function for peering / communication mechanisms. Network layer needs to be solid before looking at application layer.\\n\\n## 3. Transition from 1.0 to 2.0: what is the timeline for dapps testing their work?\\n\\n**Mehdi**- The only thing available soon will be testnets. Lighthouse will have a testnet within the next few weeks. It’s too early to guide dapp developers on what their dapp might look like on 2.0: the EVM is deprecated by EWASM. Developers should look into EWASM.\\n\\n## 4. Token moving from 1.0 to 2.0- what does that look like?\\n\\n**Justin**- Deposits can be between 1–32 ether, these are locked in the deposit address (burner address). Within the beacon chain if you are not actively validating you can transfer between addresses (perhaps for arbitrage). This is purely a system chain, with no user transactions.\\n\\n## 5. Will there be economic abstraction in 2.0?\\n\\n**Justin**- Initially the beacon chain will have very limited throughput at 16 txs per block. Wouldn’t be a great mechanism to abstract fees. One research idea is a single unified Plasma chain to pay tx fees on any shard. This removes need for ether dust on every shard to pay for transactions. This problem of fee abstraction is more pressing in 2.0 than 1.0 (note, I think there may be a slight disconnect between the question and answer. Typically this refers to paying system transaction fees in something other than the base token, e.g. tokens paying tx fees in the place ether).\\n\\n**Carl**- The beacon chain can be considered a state machine: not designed for arbitrary computation, with a finite actions and systems to update. Not designed for general purpose computation.\\n\\n## 6. Will the randomness produced by the Beacon Chain be available to smart contracts (e.g. a dice game)?\\n\\n**Carl**- Yes. We now have a secure random beacon that can be used across the chain by dapps. Unbiasable and with the same properties that are used in consensus.\\n\\n## 7. What will happen to smart contracts that are on 1.0? Migration?\\n\\n**Justin**- If you have a 1.0 contract with a long projected life, the 1.0 chain will most likely live on for decades. However, it’s important that it remains sustainable, issuance needs to not be that high. This can be accomplished through 2.0 finalisation, might be able to live on transaction fees alone. Other approach would be to embed 1.0 chain as a contract within 2.0 — this seems ambitious as an engineering question. Is it worth the time and effort?\\n\\n## 8. Will the ETH 1.0 chain be isolated?\\n\\n**Justin**- At the very least you would be able to transfer Ether between both chains.\\n\\n**Carl**- Merkel roots of data from ETH 1.0 chain can be included on 2.0 chain (proving accounts).\\n\\n## 9. Why is it necessary to reduce issuance on 1.0? If there is a chain reorg on 1.0 a year into the new chain, how would that affect 2.0?\\n\\n**Justin**- Issuance can be reduced because 1.0 is finalised by 2.0. At most it could be a 6 minute reorg from a bad miner. Issuance should be reduced because it is expensive for investors to get continuously diluted — ideally would be .5% for the entire Ethereum system. Secondly, it is environmentally expensive. With POS you get better security for a cheaper price.\\n\\n## 10. For dapp developers considering other chains who may launch sooner, how will this affect the 2.0 product?\\n\\n**Greg**- We live in a multi-chain future. If dapps want to move to other chains they will, but their users might not. Layer 2 solutions will likely fill that deficiency before forcing dapps to move to other chains.\\n\\n## 11. Could the deposit address on 1.0 be read by contracts on 2.0, allowing for some communication? What does the migration path actually look like?\\n\\n**Carl**- Goes back to the idea of using merkel roots to include data, same conditions apply if 2.0 is finalising 1.0. Long term it depends on what happens with 1.0 (1.x, EWASM), if there is a WASM interpreter running in a shard then data will be more accessible.\\n\\n**Zak**- Keep building / developing as you are, but anticipate that you may have to restart / redeploy on 2.0. Will present fewest vulnerabilities and security issues.\\n\\n**Diederik**- If the 1.0 chain keeps running, you wouldn’t want to run on both at the same time. May want to stop support on 1.0, take state roots of the dapp and reinitialise on 2.0. Doesn’t need to be defined in the protocol.\\n\\n## 12. How would you know which shard your contract gets deployed on? What do cross-shard calls look like?\\n\\n**Carl**- It will be your choice, each will have different gas markets which will lead to economic load balancing.\\n\\n**Lane**- Considered baking the load balancing into the protocol but it was incredibly complicated. Population density / cost of living analogy. Higher densities might have network effects but there are also costs associated with it. Yanking will also allow for asynchronous contract movement between shards.\\n\\n**Justin**- Cross shard calls is a design space with tradeoffs, no single answer, like Plasma. People will try different things and standards will emerge. One thing to consider is that there will be basic infrastructure at the protocol layer in the form of crosslinks. This is a way for every shard to have light client access to other shards. Most likely there will also be basic asynchronous cross-shard calls. This works by having a special contract on each shard that burns ether sent to it. The burn generates a receipt which can then be consumed on the shard on the other end of the transaction as soon as the sending shard has been finalised through the beacon chain.\\n\\n## 13. Would transactions (contract calls) spanning multiple blocks be feasible or is it better to deploy all contracts a tx might touch on a single shard?\\n\\n**Justin**- Latency from basic infrastructure would be one epoch, 6 minutes. To get anything faster you can also experiment with optimistic approaches. Assume that the checkpoint will be finalised but don’t wait for it, and then layer your next actions on top of that. If for some exceptional reason this does not occur there would be a revert mechanism built in. The design space opens up here — you can trade off certainty of execution vs. latency.\\n\\n## 14. As core researchers how can we listen to and respond to the concerns of dapp developers?\\n\\n**Lane**- Reddit AMAs, had a 2.0 AMA recently.\\n\\n**Justin**- One of the biggest concerns for 2.0 will be storage fees. Good news is that there is movement in the form of 1.x which will help give feedback. This also applies to the Plasma research, state channels, etc. Getting close to world computer will require these Layer 2 solutions.\\n\\n**Lane**- None of the 2.0 work requires a 1.0 hard fork, however, there will be experimental efforts like storage fees that will likely take place via a 1.0 HF. EWASM is also important on this front.\\n\\n## 15. VDF (verifiable delay function) ELI5? What is the difference between a VDF and POW today?\\n\\n**Justin**- We need VDFs to get a very high quality of randomness. RANDAO gets a pretty good version but these together get basically perfect randomness. ELI5: There are \\\\~100 people in a dark room, with a die in the middle. They are asked to roll the die, however some do not participate honestly because they are asleep or malicious. They cannot see the die. If there is only one honest person rolling the die, then the end result is no one can know what the final value will be. VDFs provide a mechanism to keep the lights off for a preset period of time and not before. It’s an artificial delay mechanism for seeing the unique answer that will only be seen at a future time. Malicious actors are constrained by physics.\\n\\n## 16. What is the perceived value with VDFs?\\n\\n**Justin**- Originally the idea was to harden the consensus layer because RANDAO is vulnerable to two attacks. In RANDAO, the last entity invited to reveal in an epoch can choose to not reveal — this biases the randomness by one bit. In the “last revealer attack” if they somehow manage to control the last 3 slots, then they can control 3 bits of attack surface (8 random number possibilities). If randomness can be biased in one epoch, malicious actors can use that bias even more in the next epoch —meaning you push your slot closer to the reveal period. This is called the “amplification attack”: if you control 35% of the stake, you would be able to put yourself in the last revealer position 50% of the time.\\n\\nTo address these biases at the protocol layer, we have security margins. One way is to have stronger assumptions, ie, that people are honest. If there were better randomness, your assumption that 70% of the network is honest can be reduced to 66%.\\n\\nA second, more tangible value for strong randomness (VDF) is at the application layer. Would be incredibly important for something like a billion $ lottery, where one biased bit of randomness increases the odds of payout for large players.\\n\\n## 17. How do implementer teams make sure your clients talk to each other?\\n\\n**Mehdi**- Biweekly implementer calls help to coordinate the teams on development. In terms of the protocol layer, there are also test vectors set by the Ethereum Foundation which each implementation is on par with the specification. Will hopefully see a multi-client testnets in a few weeks time.\\n\\n## 18. What are the biggest challenges facing implementers?\\n\\n**Mehdi**- Funding. This problem is not unique to the Ethereum space, affects all of open source. Need to find sustainable business models. Another challenge is balancing between their current work and staying up to date with the spec.\\n\\n**Greg**- The Chainsafe implementation in Javascript has seen issues with numbers. How to properly handle this with regard to communication between clients? Also difficult when the spec is not versioned, however this has been fixed recently by the research team.\\n\\n**Mehdi**- The naiive implementation of the spec would not work, would require a lot of optimisation. This is a requirement on top of the spec implementation.\\n\\n## 19. When should specification optimisations occur?\\n\\n**Diederik**- There is a tradeoff between optimising prematurely or researching for a better solution.\\n\\n**Carl**- From a spec writing perspective we have optimised for readability. It should be easy to understand. The research team has been moving away from a plaintext script towards python executables (exe). They want clients to come up with different optimisations to solve problems in different ways. Trying to avoid all clients failing in the same way and possibly missing better optimisations. If everyone is focused on different methods of achieving the naiive spec this is probably better for the health of the ecosystem in the long run.\\n\\n**Greg**- We need client competition to a certain degree. Client specific optimisations on top of a barebones spec leads to different tradeoffs.\\n\\n**Mehdi**- Simplicity was certainly a design goal for Ethereum Serenity. The spec does not necessarily need to have all client optimisations built into it. He views the client as a public good.\\n\\n**Lane**- It’s part of the Ethereum ethos to have multiple implementations (as compared to Zcash or Bitcoin). Important to point out that there have been consensus failures, it’s a useful method to catch bugs.\\n\\n## 20. What is the advantage to having more than 2–3 client implementations?\\n\\n**Lane**- There might be diminishing returns.\\n\\n**Diederik**- In terms of ETH 2.0 it’s important that large groups of validators do not fail at the same time if their client has the same bug. Diversity is healthy for the validator ecosystem.\\n\\n**Zak**- Language differences play a part. Different clients can be more modular depending on the usecase. There is a lack of standards / specifications for what clients are required to do — will lead to healthy competition.\\n\\n**Greg**- Diminishing returns are real, probably already. First, the spec is not quite finished and bugs are being found. Case in point, being able to transfer on the Beacon Chain activates validators and then they are being slashed because they aren’t aware. Second, readability is huge. The spec is complex, not everyone knows Rust. Third, contributions to upstream libraries. All the teams need libp2p so all each language is completing what they need, leading to a more unified feature set. ([Looks at camera:](https://youtu.be/r8235mBjHSs?t=24645) Dean, we don’t need a client in swift)\\n\\n**Lane**- Readability is important. The yellow paper is challenging to understand, he finds the Trinity source code easier. Reading the client implementation might be easier than digesting math for developers. There is also other types of experimentation going on, e.g. business models.\\n\\n## 21. What project coordination would be helpful for both developing the spec and helping across teams?\\n\\n**Greg**- Happens in gitter or side communications between implementers. The researchers are doing an incredible job letting people know what’s up, Danny especially. We’re still in the research phase, though very close to finalising. Additional formal coordination isn’t necessary quite yet, perhaps when the cross-client testnets are closer it might be more important.\\n\\n**Mehdi**- Agree, Danny is doing an amazing job. It’s also difficult in a decentralised environment because no one formally told him to do it. Wouldn’t work in a commercial context, a researcher acting as a project manager would be unheard of.\\n\\n**Greg**- Implementers call standup gives a good enough of an understanding between client teams. With a cross-client testnet it will come down to implementers chatting with each other.\\n\\n**Zak**- A working multi-client testnet has been challenging. Need conformance tests, performance metrics, functional docker files. Might be good to have Cat Herders coordinate a multi-client testnet, should not be the responsibility of the client developers. Please try to move away from writing everything to memory.\\n\\n**Diederik**- Need to shift from single to multi-client testnets. This is difficult because there is still undefined pseudo-code in the spec. There are plans to formalise these parts of the spec. They want big picture test vectors to make sure clients generally confirm state transitions and also agree on networking.\\n\\n## 22. What is the ETH 2.0 roadmap? How has it evolved?\\n\\n**Justin**- The roadmap is bigger than the spec, which only refers to Phase 0. The roadmap has evolved significantly over the years, up until recently it was primarily driven by the research team (Vitalik and Vlad mostly). The roadmap is changing in relatively smaller ways. One example is the addition of transfers — will the BETH token be fungible, will there be tax implications? It was a low hanging change. Phase 0, 1 and 2 are pretty well defined — what come after is more blurry. They would like to have a quantum secure chain after that, part of the reason they gave the grant to Starkware. Starks are probably powerful enough to handle all of those problems, including signature aggregation (replacing BLS signatures), can be useful for VDFs. Another non-quantum secure part is randomness — whereas right now they use BLS signatures, there is a new design requirement for ETH 2.0: it should be friendly to MPCs (n of m staking pools).\\n\\n## 23. What’s one thing you would change about the roadmap if you could?\\n\\n**Diederik**- In the short term, from Phase 0 to 1 there is room for concurrent research on how shards can be upgraded individually.\\n\\n**Mehdi**- We had to throw away a lot of Rust code but we learned a lot, it’s fine. One thing they would have done differently is to maybe wait until a release candidate was ready. Much better now with releases and a change log.\\n\\n**Greg**- Disagrees with the Kyokan report claim that there isn’t input from implementers to researchers, he can still ask questions.\\n\\n**Zak**- Thinks there should be more formal verification. Should be a feedback between formal verification and the eventual spec changes. Formal verification is is like establishing a blueprint for a building. Should occur before construction begins.\\n\\n## 24. Is there any interaction between the EEA and the ETH 2.0 efforts?\\n\\n**Zak**- There is not much interaction or interest in 2.0. They are focused on enterprise implementations, 2.0 seems too far into the future. Too early to say what will happen in the future.\\n\\n## 25. What is the best way to approach “execution engines” in Phase 2 (look at EVM, consult with dapp devs)? Where is the best place to discuss these ideas?\\n\\n**Zak**- [ethereum-magicians.org](https://ethereum-magicians.org/) OR [ethresear.ch](https://ethresear.ch/). Gitter is a great place to voice your opinion.\\n\\n**Greg**- For dapp devs they can still contribute to EWASM issues, join some gitters, github issues. Just because you don’t write code doesn’t mean you can’t contribute.\\n\\n**Lane**- All avenues are developer friendly, perhaps not for non-developers. Cat herders are a great way to get involved if you are non-technical. Build a design ring if you are a designer.\\n\\n\\n---\\n\\nHopefully people find this helpful. Thanks to [Fluence](https://twitter.com/Fluence_One) for livestreaming and Lane / MP for facilitating. If there are any errors or inconsistencies, comment or message me. I can also be found [here](https://twitter.com/trent_vanepps), looking for work.\",\"timestamp\":1632627824,\"title\":\"Q + A on ETH 2.0\",\"publication\":\"trent\"},\"digest\":\"9ullqlgqPptf5s1WWRIQEbJCAbR6NVu5WhuBLvTymaM\",\"authorship\":{\"contributor\":\"0x4C0a466DF0628FE8699051b3Ac6506653191cc21\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"FaggmySWmxMOpjsAfoYTethf_ADgXzieaPjX8yB3wkE\\\",\\\"y\\\":\\\"fvqw5kCn0zT3rC0oevHu8o4RDX0bca8s4EVI4INP5Yo\\\"}\",\"signature\":\"WTPURLIkQ76mvfpX2wk5mjlfLwAbcTYdvnW9-T8QTHpq8Kfbe68YVjG1FMTgyaNEVcp2Y_bdvwGPdhjmtt1jNA\",\"signingKeySignature\":\"0x55ee1e3e39dbb98d83dd8af98b152438a1a67645ff93af2b0202fb2f34e7877c6a45f9b9aa25e6ecaf09bb434ee32c4b90969c17b8fc2353f68c4d8c6eebce781c\",\"signingKeyMessage\":\"I authorize the publication of articles on trent.mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"FaggmySWmxMOpjsAfoYTethf_ADgXzieaPjX8yB3wkE\\\",\\\"y\\\":\\\"fvqw5kCn0zT3rC0oevHu8o4RDX0bca8s4EVI4INP5Yo\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"M3r2zJj7NOcZdYcTtcyvhnumXP0cBHOmzTG8HvT1Wpg\"}"