"{\"content\":{\"body\":\"> *Using scaling to address Ethereum congestion is undoubtedly helpful for larger adoption. As we all know, expensive on-chain transactions and spiked user experience are reasons why Ethereum network urges for scaling. Optimistic Rollup and ZK Rollup are two prominent Layer2 solutions. Optimistic Rollup is EVM-compatible with low technical cost, while ZK Rollup has shorter withdrawal duration and lower on-chain computing cost. zkSync, as a EVM-compatible ZK Rollup, is showing robust momentum.*\\n\\nOur 3rd workshop, presented by The Graph, of the series in **IOSG Ventures & Chainlink Layer2 Hackathon**, was live on July 18 at 8:00pm. This live has received a great bunch of supports and likes from our lovely audiences! Don‚Äôt worry if you missed out the video, click and watch the replay below! We also bring the full wrap-up in text for everyone who would love to read and learn more about it.\\n\\n‚Äî Let‚Äôs get started!\\n\\n# üîç Foreword\\n\\nSo yes, I‚Äôm at the beach. That‚Äôs where I‚Äôm going to be streaming, from the beach. Because that‚Äôs what we do. We work wherever we want, and today I‚Äôm working from the beach. I‚Äôm going to be streaming from here. I might take a little break in the middle of the streaming, grabbing something to drink or food or something, because we‚Äôre going to be here for about an hour.\\n\\nBut today we are doing a big launch of The Graph. That‚Äôs what I‚Äôm going to be talking about today. We have a pretty cool project that we‚Äôre going to build out. I‚Äôm going to talk about some of the ideas around some of the stuff that we‚Äôve done here, so we‚Äôre pretty excited about this. I‚Äôve only been on this team for about three months, but they‚Äôve been working on this for like four years. So some of the ideas that are launching today have been thought out, but they‚Äôve been theoretical ideas, even concepts that had been thrown around industry but no one‚Äôs actually implemented something that‚Äôs this complicated and this comprehensive with a user interface that people can actually interact with on a bunch of different level. So we‚Äôre pretty excited about it.\\n\\n# üîç Introduction to The Graph\\n\\nWhat I‚Äôm going to be doing today is just showing how to build out an API used on the front end. I‚Äôm going to talk a little bit about the network and how you can participate in a few different ways. We‚Äôre going to be writing some code today. So that‚Äôs mainly what this is about. If you haven‚Äôt seen the launch, let me go ahead and link to it here. See if you can check out some of the work that‚Äôs been done just by reading over the blog post.\\n\\nYeah, someone mentioned the Ethereum Conference in Paris. I don‚Äôt have tickets but still I will be there. So even if you‚Äôre in Paris, and you don‚Äôt come to that conference, hit me up. I would love to hang out and bring in a bunch of Graph swag. I am bringing T-shirts, and I am bringing stickers. I‚Äôll buy you a drink, or I‚Äôll buy you coffee. I might even buy you dinner. I‚Äôm going to be there for about a week, so I‚Äôm looking forward to that.\\n\\nI shared a link to the launch. What we launched was two new products or two new features of The Graph. One is called the Subgraph Studio, which allows developers like myself to build these open APIs on top of open datasets. I can curate my own API, meaning that I can basically say, hey, I want someone in the network to start indexing the data from my API. And I can start earning money based on the feeds that I am able to generate. I can basically find other people‚Äôs APIs and I can signal on those and make money from those as well. I can be a software engineer that just runs a node, an indexer. I can make money that way. So there are all types of ways that you can make money.\\n\\nWhat interests me the most about this is that I think this is going to be incentivizing in a way that allows people to make money. That‚Äôs the best incentive. That‚Äôs one of the incentives that drives me the most. Mainly because I grew up, I would say, poor, or anything like that, but I would say, for the first ten years of my life, I was hardly making any money.\\n\\nSo the software has been enabling me. I‚Äôve seen a lot of other people around the world, a lot of people that are actually part of The Graph protocol all over the world that have been participating since early on that they have financial freedom because of it. So I‚Äôm pretty excited about the incentive there.\\n\\nI think that‚Äôs one of the coolest things anyone can come up with an idea using all of these open datasets that are available from any of the different types of networks that we support. Right now, it‚Äôs mainly blockchain and decentralized data sources. But the idea in the future is that we‚Äôll be able to have our indexers deal with any type of open dataset. A lot of people are actually getting around that today about actually finding datasets that they want to index and building them into some type of existing networks. Writing those transactions themselves and indexing them on a Graph API is also possible.\\n\\n# üîç Idea of API Design\\n\\nWith that said, let‚Äôs come up with a cool idea for an app or an API. And I just put that API together. I deployed it. It‚Äôs now on the UI. You can go check it out in the Dashboard. Anyone that wants to use it can now build a front end on top of it. They can use the smart contracts as a transaction layer like how they would before, but they can now query those on their front end. We‚Äôre going to build out a UI that shows that. Doing so, anyone that wants to use that can use it, and any money that gets charged for that is now instead of going to massive companies like Google and AWS. Of course, the people running their infrastructure might still be on those but the actual profits are going to the developers. To me, that‚Äôs one of the coolest parts as well.\\n\\nSo with that being said, that‚Äôs just a general overview. If you‚Äôve been following The Graph, you understand some of this already. But I think a lot of the people, the miner workers you know, are web developers that are in the traditional web space. Still fairly early days. Even though we‚Äôre starting to hit some really wild and interesting numbers that they recently hit over a billion queries in a single day. We‚Äôre growing on a really fast cliff. That exponential type of growth is what you look for when you get in on a company or when you want to get in early on a technology. It‚Äôs not about the actual total number today, it‚Äôs about the growth, because in a year you stay at that same growth, you are going to be crushing it. So that‚Äôs what I‚Äôm interested in.\\n\\n# üîç Building API with The Graph\\n\\nWith that being said, I‚Äôm going to start building. Let‚Äôs go ahead and do that. I‚Äôm going to go ahead and get my computer ready. To start doing this, I‚Äôm going to close some of these apps that have opened. All right, there we go. This is The Graph website. You‚Äôve probably seen this already. What I basically want to do in this video is show you how you can build out an API and deploy it to the new UI. The studio here. Then build out a front and on top of it using Next.js. That‚Äôs what we‚Äôre going to do.\\n\\nTo get started, I‚Äôm going to go ahead and create in my terminal an empty window. To do that, I first need to increase the font size, because that‚Äôs really small. We‚Äôre going to bump this up to something like thirty-three. All right. I‚Äôm in my terminal window where I‚Äôm going to create a new Subgraph. I think if you look at the Explorer which is also something we are launching today, you can see some of the apps. Some of the APIs are already on the decentralized network. PoolTogether is a really popular one. Uniswap, of course, doing billions of dollars in transactions. So pretty big apps are already here. These are like our launch partners, people that launch today. But if you look at one of these APIs, you‚Äôre familiar with maybe some of these applications that they‚Äôre driving. A lot of these are financial applications. To me the more interesting ones for demo purposes are actually artwork, the visual stuff. The thing that I‚Äôm going to be building out is for an NFT marketplace to visualize that. Because I think financial data is harder to visualize. It isn‚Äôt interesting for a user interface demo like this.\\n\\n# üîç Building out a Subgraph\\n\\nBasically, what I‚Äôm going to be doing is building out a Subgraph. So we go to the Legacy Explorer, and I go to Zora. You‚Äôll see a bunch of Zora Smart contracts that had been deployed for Subgraphs. Then using this data like the content of a URL like this, you can actually see a little bit more interesting data. So I order by ID, then we pull up something from here. When you have stuff like this, it‚Äôs a little cooler like videos and stuff that you can actually show. This isn‚Äôt loading right now. Let‚Äôs see here. Maybe I can find an image. There we go. Stuff like that. That‚Äôs what we‚Äôre going to be doing.\\n\\nLet me just check and see if there‚Äôs any questions that I‚Äôm missing. I should have. I will get back and answer questions when I have a moment.\\n\\nThis is being recorded. It will be available on my Twitch as well as my YouTube later. What I basically want to do is build out for Zora. So zora.co and this is their website. They have a bunch of NFTs that people are buying and selling. This is kind of what I want to build out a UI for. Another interesting one is Foundation. If you go to foundation.app, this is actually really nice as well. You know you can see the current bid, so this one is like four thousand dollars or two Eth. This one is like five thousand dollars. So this one Foundation and Zora would help us get a decent amount of action.\\n\\nI‚Äôm using Zora. Zora again is an NFT marketplace. We‚Äôre going to build out a Subgraph, and then we‚Äôre going to build out a UI for that. To get started, I‚Äôm going to Subgraph Studio. I‚Äôll go ahead and create a new Subgraph. This is going to be Zoralivestream. And here see that, we have our Subgraph available now in the Studio. We can now basically create and write the code locally. Then we‚Äôre going to deploy this thing and push it up here to the actual Studio Dashboard. We have some instructions here on how to do that, but actually the best instructions are going to be on the new website. The new docs that we have. You can also go to the blog Building Subgraphs with Subgraph Studio. This is actually going to be essentially what we walk through today. Actually I personally wrote this blog post. This is going to be the API that we‚Äôre building today. It should walk you through all the steps.\\n\\nSo we‚Äôve already created this. We now have our slug. The status is UNDEPLOYED, meaning that we‚Äôre not deployed right now. We have our deploy key. We have some installation instructions, Graph CLI and things like that. This is what we‚Äôre going to be using. Now we‚Äôre ready to start writing some codes. Now that we have this place over here, we can go back to our CLI.\\n\\nI‚Äôm going to go ahead and install the CLI. I think this is already installed I assume. I‚Äôm just going to install it again and then once this is installed, we have the binary. And we could start using The Graph CLI. While that‚Äôs installing, I‚Äôm going to go through this tutorial. This is essentially again what I‚Äôm kind of walking through. This shows you how to kind of get set up. I‚Äôve already passed that up. I‚Äôve created my Subgraph, and now we‚Äôre kind of be right here where we install. Now that we have The Graph CLI installed, you should be able to just run graph. And see the binary is giving you instructions there, graph ‚Äî help will kind of give you some common commands. What we want to do is init, so we want to initialize the Subgraph. What this basically do is create all the boilerplate that you need for your API. This is going to be the command that we run graph init. Here we pass it a couple of flags. So we‚Äôre passing the contract name. So this is going to be what we‚Äôre calling this data source. And for us, it‚Äôs going to be token, because these are going to be digital assets using the OpenZeppelin ERC721 standard, which is a non-fungible Token. So Token makes a lot of sense.\\n\\nWe‚Äôre going to say index-events, meaning that we‚Äôre going to look inside the APIs, or the application binary interfaces, which is an Ethereum smart contract. An API essentially that you can use to interact with a contract. It will look inside of the ABI and will pull down the actual events that are admitted, create some boilerplate code locally for us. So this just a helper to write some code essentially for us based on the events .\\n\\nWe also were saying we want to use Subgraph Studio, because now we have both the hosted service as well as the Studio. The studio is what all most future apps are going to be using, but we still want to support the old service. We specify studio, and then we can also specify that smart contract that we‚Äôre working with. So I said we‚Äôre using Zora. This number here is the Zora smart contracts. How would you get that? If you go to Zara developer documentation, you can get it there.\\n\\nThey had a link to the smart contracts here. Of course, though, you can go to Etherscan. Etherscan has pretty much everyone‚Äôs smart contracts listed there. And you can find it in some other ways, but I would say a lot of contracts have their address public. So in this case, Zora even goes as far as to have a developer documentation site. Foundation also does this, so Foundation is cool too. Fnd.dev has all of their Subgraphs. They even have their own Subgraph that they support. I think Zora does as well. Yeah, they have their own Subgraph. So you could use their existing Subgraph, but we‚Äôre basically building on our own from scratch.\\n\\nSo that‚Äôs kind of from where this contract comes. The contracts are just right here. So now that we‚Äôve done that, we can just hit enter and this should go ahead. To walk us through the steps, we only really need one more thing the Subgraph name. I can just copy that from the slug right here, then all of these things we could just take the defaults. So this is going to create all of that boilerplate code locally for us.\\n\\nNow I should be able to go into this new directory and go ahead and open up my text editor. All right, cool. So this is our boilerplate code, literally everything you really need to publish a Subgraph. It‚Äôs made up of other three main parts. If you can understand these three main pieces, you can build an API on top of any of the networks that we support. You have the schema.graphql, which is graph‚Äôs schema. We could delete all of that for now. We have our subgrph.yaml. This subgrph.yaml is your configuration. It is by default about thirty-five lines of code that‚Äôs given to you, or just going to be a little bit less, but your subgrph.yaml is basically almost like the infrastructure of code. We‚Äôre telling the indexer that we‚Äôre deploying this API for what to do with the data sources that we‚Äôre going to be working with. We‚Äôll look at that a little more in a second.\\n\\nThen the last thing you have is your src/mapping. So these are mapping templates. If you‚Äôve ever worked with something like AppSync, or even The GraphQL, you probably worked with a mapping template in the past. So these just define‚Ä¶they‚Äôre essentially handler functions. You have the events and you want to handle those events. In our case we might have an event where someone meant to do token and we want to handle that data. We want to store it in our local our own API we‚Äôre going to store that and make it available. So the mappings. A lot of these ideas transferred me directly from the GraphQL days working in the Web2 space in traditional applications and stuff. So those are the main things, your schema.graphql, your subgraph.yaml and your mappings.\\n\\n# üîç Usage of GraphQL\\n\\nThe first thing we‚Äôll mess with is the GraphQL schema. I‚Äôm going to copy and paste some of the entities of the two types that we‚Äôre working with. One is the Token type and one is the User type.\\n\\nSo if we look at Zora, you see that we have these NFTs, and they are associated with a user‚Äôs address. So we want to be able to store that information, and we also want to store the metadata about the token itself. So that‚Äôs why we have these two entities.\\n\\nFor the token, we just have all the metadata that we want to store. We can get this metadata from the actual event that we‚Äôre going to be working with. Or if we really wanted to, we could actually go out to a separate smart contract or data source and get data for a type. Or we can actually go directly into The Graph node itself and get data as well.\\n\\nIf we really wanted to, we could actually go out to a separate smart contract or data source and get data for a type or we can actually go directly into The Graph node itself and get data as well.\\n\\nSo in the mappings, you can essentially work with different data sources that are going to populate the types that were defining here and if you‚Äôve ever worked with the GraphQL.\\n\\nYou probably understand that an exclamation point means it‚Äôs a required field and if it‚Äôs not exclamation point means it‚Äôs an optional or a nullable field so we‚Äôre going to store the token ID, the contentURI, the metadataURI, the createdAtTimestamp, the creator and the owner then we have the user type the user is basically going to have a one-to-many relationship so a user has many tokens that they‚Äôve created here and then they have many tokens that they‚Äôve purchased so a user can be a creator or a consumer and the way that we create the relationships or using these directives.\\n\\nAnd if you‚Äôve ever used something like Amplify and many other different GraphQL instructions you might have seen something like this where you have a directive and in this casewe‚Äôre kind of saying we want to have this created field derive from the creator here which is an address so the address would be a wallet address and then basically this is going to give us the ability to have a relationship between the token and the user and the user and the token itself or I would say the array of tokens.\\n\\n# üîç Setting startBlock\\n\\nAlright, with that being said, we can go ahead and save that and we have our subgraph.yaml so here we‚Äôre going to make a few changes we already have the address, which is set when we created this. The next thing we want to do is set the startBlock. The starkBlock is basically going to tell the indexer where to start indexing this data because if you deploy it as it is it will start from the genesis block of the blockchain so it will go to the very first transaction on Ethereum and worked his way up from there which is time-consuming so instead what we can basically do is set the startBlock so for the startBlock you can go to the smart contract itself.\\n\\nLet‚Äôs see here. I think this is the contract itself so how would you find this so you can go to Transactions. You can go to the very last transaction and this is it right here so that‚Äôs the first start block that we would say that‚Äôs kind of literally the block that we‚Äôre using here.\\n\\nNow, for the entities this is the next step that we want to make these are going to match the GraphQL entities so we have a token and we have a user the last thing we want to do is deal with the eventHandlers the three events that we‚Äôre going to be working with are going to be transfer this event is fired every time a token is created or a token is transferred so if I create a token this event gets fired if I transfer it to someone else, this event gets fired this is a good way to keep track of all the tokens that are in existence and then the other two handlers are going to handle updates so if I change the metadataURI, I change the tokenURI, I can track that here.\\n\\n# üîç Writing Mapping\\n\\nSo these are going to call functions that are in our mappings called handleTokenMetadataURIUpdated, handleTokenURIUpdated and handleTransfer and that‚Äôs it.\\n\\nWe can go ahead now back to our CLI, what we might want to do is write our mappings in order to write our mappings we actually had a library called the GraphTS which is a Graph typescript library that we support along with CLI using this library, you can talk directly to the blockchain itself you can talk to Ethereum but you can also talk to The Graph node if you‚Äôve already stored some data there and you want to retrieve that data you can talk to it.\\n\\nWe actually use The Graph CLI to generate a lot of this code for you that makes it pretty easy to work with to generate that code all we need to do is run a graph codegen. This will do a combination of things, it will look into our GraphQL schema as well as the ABIs for the smart contract. It will go ahead and generate a bunch of functions as well as types for us to use so the types have been generated successfully.\\n\\nWe should be able to go to our generated folder and see some stuff that‚Äôs been generated the two classes that we should have are token and user so that‚Äôs good we‚Äôre not going to need to update this or anything just showing you what that does the next thing we‚Äôre going to do is open the mappings.\\n\\nI‚Äôm going to just go ahead and delete all this stuff. We‚Äôre going to go ahead and import the stuff that we want to use so if I go to the blog post here. This code is formatted not too well but I will format it in just a second. The first things that we‚Äôre importing are from the token folder which is under the generated folder the TokenURIUpdatedEvent and TransferEvent are events that allow us to have type safety. The token contract referenced here is Token as TokenContract. This is a class that allows us to interact with the actual smart contract so we can make calls to the smart contract using this and then Token and User. I think these are classes that allow you to talk to The Graph node so this basically means if I store something as an indexer, I want to retrieve that data. I can use these classes here we have three functions we need to deal with so handleTokenMetadataURIUpdated, handleTokenURIUpdated handleTransfer so we need to have basically three handler functions in our mappings so the biggest one is this handleTransfer this is a function that will handle the minting or the transfer of a token so with that being understood we need to handle a couple of different cases here.\\n\\nWe need to handle if the token has never been created before and we also can handle if it has already been created, right because if it‚Äôs being minted that means it‚Äôs not there yet if it‚Äôs being transferred to someone else that means it is there so the first thing that we can do is we can basically use the Token here from our generated code to first look into the existing node so we‚Äôre basically calling into that database. If this token exists, return it. If not, we‚Äôre going to go ahead and create it and then here we‚Äôre basically just setting a bunch of metadata like the creator, the tokenID and createdAtTimestamp. We then are going to call to the smart contract itself because in the event, we are only getting certain data but we can call back to the smart contract to get other data so the thing that we need from the smart contract is contentURI and metadataURI so we‚Äôre calling the smart contract here we‚Äôre adding additional fields to this object here\\n\\nWe have a token, we are adding the creator, the tokenID, and createdAtTimestamp. There is other content information as well. We then update the owner or we set the owner maybe because it could be a brand new token with no owner we then save that to The Graph node. We then also do the same thing with user if the user exists, we load the user and if not, we go ahead and create the user the last two functions that we need or for handling the handleTokenURIUpdated and handling the TokenContentURIUpdated so tokenURIUpdated just fetches the token and then updates contentURI and saves it the other one we have is TokenMetadataURIUpdated so we don‚Äôt have that defined yet so I‚Äôm going to go ahead and do that.\\n\\nI‚Äôm just going to copy this event is actually going to be. Github Copilot is doing some work for me there so we have this tokenMetadataURIUpdated event. We want to set that metadataURI. I think we‚Äôre good so now we have written our mappings. We have three functions that we‚Äôre dealing with handleTransfer, handleTokenURIUpdated and tokenMetadataURIUpdated and then we have our Subgraph here that‚Äôs defining those events. I think we‚Äôre ready to deploy this thing.\\n\\nSo what I want to do is go to CLI and I‚Äôm gonna run graph deploy and here we can actually define the studio so we‚Äôre going to say dash dash studio then I want to go ahead and pass in the subgraph name which is right here.\\n\\nI‚Äôll give it a label of a version of zero point 1, and oh I need to go ahead, and first so let me go ahead and graph auth dash dash studio. I can get my deploy key right here, alright, so this should be deployed. So if this looks good, then we should be ready to go back to our dashboard here, and as you can see, it‚Äôs already been updated with the GraphQL playground. And now we can go ahead and start running some queries, and then we‚Äôre going to transfer this into our next JS app. So we might pass in some arguments like orderDirection, descending, and then maybe orderBy createdAtTimestamp, and then we already start seeing some data is coming back. If we look at the contentURI, we see that we have the actual contentURI coming back, for the content coming back. Alright so our subgraph has been deployed. If we want to know how to query this from our front end, we can actually go here for details, and we have our query URL, so I can copy this. I might go to something like a graphQL bin. I think it is.\\n\\nYou can see that we can also use this graphql bin, or any of these different GraphQL UIs. So our API is working. That‚Äôs the URL that we‚Äôre going to use. Now we can go ahead and jump into a front end application. So what I want to do is create a new next JS app. We‚Äôre gonna call this like zora UI. I guess that should show up here, and what we want to do is build out a UI on top of this API, so what I‚Äôm going to do is use tailwind, because tailwind is pretty nice. And I‚Äôm going to go ahead and install the stuff I need for tailwind, then I‚Äôm gonna initialize the tailwind project, and then we‚Äôre gonna go into the globals.css, and we‚Äôre gonna go ahead and do that.\\n\\nAnd now we‚Äôre ready to go. So in the UI, I‚Äôll probably go to index.js, and this is what we‚Äôll do our work. Go ahead and delete all this code here, and the things that I‚Äôll need are going to be useState and useEffect from react. And I‚Äôll also probably need to go have some code that I can reference here. I don‚Äôt want to kind of like references directly, but I do want to kind of like use it to get started. So we have getServerSideProps. This is going to be where we call our fetchData function, and fetchData is going to call our GraphQL API, and then it‚Äôs going to come in here as props, and then we‚Äôll just console.log like that and maybe we don‚Äôt even need actually useState because we‚Äôre gonna be using next year, so we can just pass it all in this props. So this is kind of where we‚Äôre going to get started.\\n\\nSo what I want to do is how do we actually call the GraphQL API. Well you know, we have our input here in our docs. We also have some documentation around. You know, different GraphQL clients, so you can use something like Apollo, or you can use something like URQL. I think I‚Äôm gonna go with URQL just because it‚Äôs a little less code. So I‚Äôm gonna go ahead and install URQL and GraphQL, so we have URQL and GraphQL installed now, and what I want to do is basically let‚Äôs just say copy all this code, and then we‚Äôre going to kind of break it up in our app. So we have createClient from urql. We have our API URL, the API URL that we want to work with is going to be this API. This URL here I‚Äôm in. For the query, we want to just use a query that we know is going to work. So we go back to my API, and just write a query, and then I‚Äôll copy that and paste it over, and we will also say we want to get the first 10.\\n\\n# üîç Running the Program\\n\\nSo that‚Äôs our query. This is gonna be our client. We kind of say create client. We set the URL, and then we can call that for the data, so let‚Äôs go ahead and just do this, and then just console that log data. We‚Äôll just return like an empty array. Alright, alright, so we have our base functionality ready to go. We can go ahead and run this. So looks like I have to stop another server I have running, so localhost 3000, and when this runs, I think we should be seeing this logged out here. So there we go, there we have it. We have our data there, so we have data.data.tokens. So I might say return data.data.tokens, and then in our UI, we see that we have our tokens that should show up. All right, there we go. So we have our 10 tokens.\\n\\nWe have our contentURI. We have our metadataURI. The metadataURI has stuff like this where you have kind of like the mimeType, the name, the version, the description, stuff like that that you can use in your user interface. So that‚Äôs great. So we have kind of all the base functionality. Now we just need to build out some design on it. So for the design stuff and actually one other thing we might have to consider is like mapping over the data itself, because the way it‚Äôs coming back. We might want to kind of like to change it up a little bit, so for instance, one thing that we don‚Äôt know is directly from this data are things like the mimeType, so to get the mimeType which is going to allow us to display that, we actually have to call a fetch, call an axios or some types of HTTP request to get this JSON data. And that way, we can kind of know if it‚Äôs an image or if it‚Äôs a video or if it‚Äôs a gif, how are we going to display that.\\n\\nWe also just want this data, this metadata anyway. So what we can basically do is kind of like have a function right here that maps over this data. So what we‚Äôre going to do is we‚Äôre going to say something like data.data.tokens.map, and then we‚Äôre going to kind of like map over everything, and then we‚Äôre going to call fetch to kind of get that metadata now. Luckily I‚Äôve already created a function that does this. That way, we don‚Äôt have to like walking through all of that. I‚Äôm going to go to my GitHub. I have this fetch data function. I‚Äôm just going to replace that with this. Maybe delete some of the console.log. Okay cool. So this function is basically going to map over all of the tokens and we‚Äôre going to call out to fetch the metadata, and then we‚Äôre going to kind of like update the type based on the metadata.\\n\\nSo if it‚Äôs mp4, we want to show a video. If it‚Äôs audio, we want to show audio. If it‚Äôs image, we want to show image, and then once we have that new updated metadata, or refresh, unless we broke something here, we should see that metadata. I think I‚Äôm going to update the query to just return the first one for now. Now I‚Äôm going to restart the server. Alright so here are our tokens, we have our metadata, we have our description, we have our mimeType, we have our name, and we have the version.\\n\\n# üîç Building out the Actual Styling\\n\\nThe last thing we want to do is build out the actual styling using tailwind and also have an example UI for that that we‚Äôre going to use. So I‚Äôm going to go ahead and copy this, and I will tweet out and make all this stuff available, and I‚Äôll probably put it in the comments as well, but the code for this, but it‚Äôs nothing too fancy. It‚Äôs just kind of some basic css using tailwind, but what we‚Äôre gonna do is this ‚Äî we have our props, we have our tokens, so if we refresh, we now see that we have our UI here, and what I might do now is instead of returning one, let‚Äôs go ahead and bump that back up to like 10. Oh that‚Äôs ugly. Oh I think I know what I‚Äôm missing, missing this. There we go. So now our UI is showing, you know, all the different NFTs, and I must have not taken into consideration some type of mimetype, so let‚Äôs see what mime type that is, or just may not be loading for whatever reason.\\n\\nIt looks like there might. Okay looks like this one‚Äôs loading. So it looks like this is audio. I‚Äôm unsure about why the audio isn‚Äôt working, but I can kind of look into that, but that‚Äôs kind of the demo we just wanted to kind of show you how to build that out, and I think the interesting thing you might do at this point, if you‚Äôre a developer and you‚Äôre willing to make money off one of your APIs, I think this is like, again, the power of having a self-governing application that‚Äôs out there in the wild that people can basically compete against each other based on quality to build out the most valuable different APIs, and you can actually publish this to the network and start earning query fees on it. So if you publish this, then anyone that wants to use it can use it, and based on the usage, you‚Äôre gonna make money. You don‚Äôt even really have to do anything. You just put it out there, and then if people use it, then you‚Äôre going to basically make a portion of the money from the usage, and this is done by writing your information and your transaction of the publication to the blockchain.\\n\\nSo this is pretty interesting, because you‚Äôre basically publishing and once it‚Äôs there, it‚Äôs always there, and you know, that‚Äôs to me pretty powerful, and if you want to do that, you would basically need to have some tokens, so I have some tokens and I can basically publish either to Rinkeby or the main network. So I can go here to Rinkeby, and here I have some tests, go ahead and publish this, select Rinkeby network and probably needs to do something with my go ahead and disconnect from all these different accounts, and then reconnect. We try this one more time. It looks like I‚Äôm having some issues publishing. I‚Äôll have to look into what‚Äôs going on with that. It looks like I have. It‚Äôs showing I have zero eth for some reason, but that‚Äôs not the case. Oh I think I may I know what I need to do. Let me go ahead and disconnect, and then connect again. So I think I was authenticated with the wrong wallet, so after this is published, it‚Äôll show up on the network, and I can test it out because this is the Rinkeby test network, but if you publish this to the mainnet, that‚Äôs when you would have people starting to basically be able to like pay if they user it.\\n\\nThis interview was very fruitful, thanks to Nader Dabit from The Graph, a project that solves this problem with a hosted service that indexes blockchain data. These indexes (‚Äúsubgraphs‚Äù) can then be queried using the standard GraphQL API. In simple terms, subgraphs are like developer-written data indexes for specific business logic, and once the business logic is deployed, then it will keep updating the corresponding database based on the deployment to make it easy for developers to extract and call at any time. We will continue to invite more guests to participate, whether in the form of interviews, workshops or any other way, we hope to bring more inspiration to those who are interested in exploring layer2 in depth, and to do our best for this!\\n\\n‚Äî END\\n\\n# üë®‚Äçüéì About Speaker\\n\\n***Nader Dabit*** currently works at Edge and Node to help build a decentralized future. He previously led developer advocacy for front-end web and mobile at Amazon Web Services; focused on GraphQL, cross-platform and cloud-enabled web and mobile application development. He developed applications and reference architectures on AWS using a combination of GraphQL and serverless technologies.\\n\\n# ü§© Upcoming Events\\n\\nNext, we will have Polygon, Aztec and other projects bring us solid experience and great insights! More workshops to be announced soon. Stay tuned!\\n\\n**Polygon**\\n\\n* TopicÔºö Scaling Your Dapps using Polygon\\n* TimeÔºö2021.7.20\\n\\nüëÄ Live hereÔºö**<http://live.bilibili.com/23288126>**\\n\\n**Aztec**\\n\\n* TopicÔºöTBD\\n* TimeÔºöpending\\n\\nüëÄ Live hereÔºö**<http://live.bilibili.com/23288126>**\",\"timestamp\":1641355882,\"title\":\"The Graph Featured | Building on Ethereum with GraphQL, The Graph, and Next.js\"},\"digest\":\"erzQfYcg0QRKRddRq3IyvDGlJFJFpO3RJNChnwcZnw8\",\"authorship\":{\"contributor\":\"0xd8159c4DD43FEe99FA86D0BAaCA7a9cC33334864\",\"signingKey\":\"{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"IrNwRyyV5qeEAVKrYYbR2GwKgwV9oiBiSE4OmxNmg_A\\\",\\\"y\\\":\\\"crLJpYwXR67C4ldGG508kcIM-ReUBDH5YblmiE3RDmU\\\"}\",\"signature\":\"VQNmArlmzwmmFJHtvuTfWveUBExQrW20ywqpMq3z6o1lkt2b-7pq-lCREAzscEQvLTeZByR5pJ1yJ25Ga3lCuQ\",\"signingKeySignature\":\"0x3cacac780fe70792bba7704453b9c0e94a2f67fde8f900d8fb3c5673ec818826037300d7a781c78d788fd5b8f77006f8346e179822bce17f127a3557e49a5e211c\",\"signingKeyMessage\":\"I authorize publishing on mirror.xyz from this device using:\\n{\\\"crv\\\":\\\"P-256\\\",\\\"ext\\\":true,\\\"key_ops\\\":[\\\"verify\\\"],\\\"kty\\\":\\\"EC\\\",\\\"x\\\":\\\"IrNwRyyV5qeEAVKrYYbR2GwKgwV9oiBiSE4OmxNmg_A\\\",\\\"y\\\":\\\"crLJpYwXR67C4ldGG508kcIM-ReUBDH5YblmiE3RDmU\\\"}\",\"algorithm\":{\"name\":\"ECDSA\",\"hash\":\"SHA-256\"}},\"nft\":{},\"version\":\"12-21-2020\",\"originalDigest\":\"UYEkIoKSx_7CVqzjw9eSs1t1BwWZJKK3k2MQCj3vwrA\"}"